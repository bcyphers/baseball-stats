import numpy as np
import matplotlib.pyplot as plt
from collections import Counter

## Setup:
# looks for "plays.csv" in the present working directory
# this file should be generated by cwevent using the following command:
#
# $ cwevent -f 2,3,4,8,9,26,27,28,78,79 -x 45 path/to/data/*.EV* > plays.csv
#
# see https://www.retrosheet.org/eventfile.htm and
# http://chadwick.sourceforge.net/doc/cwevent.html#cwtools-cwevent for more info
# about data files and tooling.

def main():
    last_team = 0
    last_score = 0
    last_inning = 0
    is_mo2_inning = False

    mo2_innings = []
    reg_innings = []
    extra_innings = []

    f = open('plays.csv')

    for l in f:
        # parse the output from cwevent
        data = l.strip().split(',')
        inning, team, outs, vis_score, home_score = [int(i) for i in data[:5]]
        first, second, third = data[5:8]
        game_start = data[8] == '"T"'
        game_end = data[9] == '"T"'
        runs_on_play = int(data[10])

        inning_end = False

        # this is the last play in the game
        if game_end:
            score = [vis_score, home_score][team] + runs_on_play

            # should we count these innings? they'll be biased cause one run is
            # often enough to win
            #inning_end = True

        # this is the first play in a new inning
        if team != last_team and not game_start:
            # get the score for whoever was up last
            score = [vis_score, home_score][last_team]
            inning_end = True

        # if a half-inning has just ended, tally up the score
        if inning_end:
            # tally up runs for an inning that started with a man on second
            if is_mo2_inning: # and last_inning > 9:
                mo2_innings.append(score - mo2_score)

            # tally runs for an extra inning
            if last_inning > 9:
                extra_innings.append(score - last_score)

            # tally runs for a regular inning
            reg_innings.append(score - last_score)

            # note the score for whoever is up now
            last_score = [vis_score, home_score][team]

            # this isn't a man-on-second inning yet
            is_mo2_inning = False

        if game_end:
            last_score = 0

        last_team = team
        last_inning = inning

        # we're interested in innings that start with a man on second and nobody
        # out (first and third also need to be empty)
        if outs == 0 and second != '""' and first == third:
            is_mo2_inning = True
            mo2_score = [vis_score, home_score][team]

    f.close()

    return mo2_innings, extra_innings, reg_innings


# Graph the distributions
def graph_results(innings):
    any_runs = len([i for i in innings if i])
    num_innings = float(len(innings))
    counter = Counter(innings)
    x = range(max(innings) + 1)
    y = [counter.get(i, 0) / num_innings for i in x]
    plt.bar(x, y)
    plt.show()


def get_probs(innings):
    # the probability that a team scores this many runs in any given inning
    probs = {k: v / len(innings) for k, v in Counter(innings).items()}

    # the probability that two teams score the same amount of runs in an inning
    p_tie = sum(i ** 2 for i in probs.values())

    # the expected number of extra innings until the tie is broken
    ev_extras = 1 / (1 - p_tie)


if __name__ == '__main__':
    mo2_innings, extra_innings, reg_innings = main()

    print('All innings (%d):' % len(reg_innings))
    graph_results(reg_innings)

    print('Extra innings (%d):' % len(extra_innings))
    graph_results(extra_innings)

    print('Innings with a man on 2nd (%d):' % len(mo2_innings))
    graph_results(mo2_innings)
